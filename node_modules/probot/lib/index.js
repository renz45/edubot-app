"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProbotOctokit = exports.Application = exports.Context = exports.createProbot = exports.Probot = void 0;
// tslint:disable-next-line: no-var-requires
require("dotenv").config();
const lru_cache_1 = __importDefault(require("lru-cache"));
const deprecation_1 = require("deprecation");
const pino_http_1 = __importDefault(require("pino-http"));
const application_1 = require("./application");
Object.defineProperty(exports, "Application", { enumerable: true, get: function () { return application_1.Application; } });
const setup_1 = require("./apps/setup");
const context_1 = require("./context");
Object.defineProperty(exports, "Context", { enumerable: true, get: function () { return context_1.Context; } });
const probot_octokit_1 = require("./octokit/probot-octokit");
Object.defineProperty(exports, "ProbotOctokit", { enumerable: true, get: function () { return probot_octokit_1.ProbotOctokit; } });
const get_log_1 = require("./helpers/get-log");
const get_private_key_1 = require("./helpers/get-private-key");
const resolve_app_function_1 = require("./helpers/resolve-app-function");
const create_server_1 = require("./server/create-server");
const webhook_proxy_1 = require("./helpers/webhook-proxy");
const get_error_handler_1 = require("./helpers/get-error-handler");
const get_octokit_throttle_options_1 = require("./octokit/get-octokit-throttle-options");
const get_probot_octokit_with_defaults_1 = require("./octokit/get-probot-octokit-with-defaults");
const alias_log_1 = require("./helpers/alias-log");
const log_warnings_for_obsolete_environment_variables_1 = require("./helpers/log-warnings-for-obsolete-environment-variables");
const get_webhooks_1 = require("./octokit/get-webhooks");
log_warnings_for_obsolete_environment_variables_1.logWarningsForObsoleteEnvironmentVariables();
// tslint:disable:no-var-requires
const defaultAppFns = [require("./apps/default")];
// tslint:enable:no-var-requires
class Probot {
    constructor(options) {
        if (process.env.GHE_HOST && /^https?:\/\//.test(process.env.GHE_HOST)) {
            throw new Error("Your `GHE_HOST` environment variable should not begin with https:// or http://");
        }
        //
        // Probot class-specific options (Express server & Webhooks)
        //
        options.webhookPath = options.webhookPath || "/";
        options.secret = options.secret || "development";
        this.log = alias_log_1.aliasLog(options.log || get_log_1.getLog());
        if (options.cert) {
            this.log.warn(new deprecation_1.Deprecation(`[probot] "cert" option is deprecated. Use "privateKey" instead`));
            options.privateKey = options.cert;
        }
        this.apps = [];
        // TODO: Refactor tests so we don't need to make this public
        this.options = options;
        // TODO: support redis backend for access token cache if `options.redisConfig || process.env.REDIS_URL`
        const cache = new lru_cache_1.default({
            // cache max. 15000 tokens, that will use less than 10mb memory
            max: 15000,
            // Cache for 1 minute less than GitHub expiry
            maxAge: Number(process.env.INSTALLATION_TOKEN_TTL) || 1000 * 60 * 59,
        });
        const Octokit = get_probot_octokit_with_defaults_1.getProbotOctokitWithDefaults({
            githubToken: options.githubToken,
            Octokit: options.Octokit || probot_octokit_1.ProbotOctokit,
            appId: options.id,
            privateKey: options.privateKey,
            cache,
        });
        const octokit = new Octokit();
        this.throttleOptions = get_octokit_throttle_options_1.getOctokitThrottleOptions({
            log: this.log,
            redisConfig: options.redisConfig,
        });
        this.state = {
            id: options.id,
            privateKey: options.privateKey,
            cache,
            githubToken: options.githubToken,
            log: this.log,
            Octokit,
            octokit,
            throttleOptions: this.throttleOptions,
            webhooks: {
                path: options.webhookPath,
                secret: options.secret,
            },
        };
        this.webhooks = get_webhooks_1.getWebhooks(this.state);
        this.server = create_server_1.createServer({
            webhook: this.webhooks.middleware,
            logger: this.log,
        });
        const { version } = require("../package.json");
        this.version = version;
    }
    static async run(appFn) {
        const pkgConf = require("pkg-conf");
        const program = require("commander");
        const readOptions = () => {
            if (Array.isArray(appFn)) {
                program
                    .usage("[options] <apps...>")
                    .option("-p, --port <n>", "Port to start the server on", process.env.PORT || 3000)
                    .option("-H --host <host>", "Host to start the server on", process.env.HOST)
                    .option("-W, --webhook-proxy <url>", "URL of the webhook proxy service.`", process.env.WEBHOOK_PROXY_URL)
                    .option("-w, --webhook-path <path>", "URL path which receives webhooks. Ex: `/webhook`", process.env.WEBHOOK_PATH)
                    .option("-a, --app <id>", "ID of the GitHub App", process.env.APP_ID)
                    .option("-s, --secret <secret>", "Webhook secret of the GitHub App", process.env.WEBHOOK_SECRET)
                    .option("-P, --private-key <file>", "Path to certificate of the GitHub App", process.env.PRIVATE_KEY_PATH)
                    .parse(appFn);
                return {
                    privateKey: get_private_key_1.findPrivateKey(program.privateKey) || undefined,
                    id: program.app,
                    port: program.port,
                    host: program.host,
                    secret: program.secret,
                    webhookPath: program.webhookPath,
                    webhookProxy: program.webhookProxy,
                };
            }
            const privateKey = get_private_key_1.findPrivateKey();
            return {
                privateKey: (privateKey && privateKey.toString()) || undefined,
                id: Number(process.env.APP_ID),
                port: Number(process.env.PORT) || 3000,
                host: process.env.HOST,
                secret: process.env.WEBHOOK_SECRET,
                webhookPath: process.env.WEBHOOK_PATH,
                webhookProxy: process.env.WEBHOOK_PROXY_URL,
            };
        };
        const options = readOptions();
        const probot = new Probot(options);
        if (!options.id || !options.privateKey) {
            if (process.env.NODE_ENV === "production") {
                if (!options.id) {
                    throw new Error("Application ID is missing, and is required to run in production mode. " +
                        "To resolve, ensure the APP_ID environment variable is set.");
                }
                else if (!options.privateKey) {
                    throw new Error("Certificate is missing, and is required to run in production mode. " +
                        "To resolve, ensure either the PRIVATE_KEY or PRIVATE_KEY_PATH environment variable is set and contains a valid certificate");
                }
            }
            probot.load(setup_1.setupAppFactory(probot.options.host, probot.options.port));
        }
        else if (Array.isArray(appFn)) {
            const pkg = await pkgConf("probot");
            probot.setup(program.args.concat(pkg.apps || pkg.plugins || []));
        }
        else {
            probot.load(appFn);
        }
        probot.start();
        return probot;
    }
    /**
     * @deprecated use probot.log instead
     */
    get logger() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.logger" is deprecated. Use "probot.log" instead`));
        return this.log;
    }
    /**
     * @deprecated `probot.webhook` is deprecated. Use `probot.webhooks` instead
     */
    get webhook() {
        this.log.warn(new deprecation_1.Deprecation(`[probot] "probot.webhook" is deprecated. Use "probot.webhooks" instead`));
        return this.webhooks;
    }
    receive(event) {
        this.log.debug({ event }, "Webhook received");
        return Promise.all(this.apps.map((app) => app.receive(event)));
    }
    load(appFn) {
        if (typeof appFn === "string") {
            appFn = resolve_app_function_1.resolveAppFunction(appFn);
        }
        const app = new application_1.Application({
            id: this.state.id,
            privateKey: this.state.privateKey,
            log: this.state.log.child({ name: "app" }),
            cache: this.state.cache,
            githubToken: this.state.githubToken,
            Octokit: this.state.Octokit,
            octokit: this.state.octokit,
            throttleOptions: this.throttleOptions,
            webhooks: this.webhooks,
        });
        // Connect the router from the app to the server
        this.server.use(app.router);
        // Initialize the ApplicationFunction
        app.load(appFn);
        this.apps.push(app);
        return app;
    }
    setup(appFns) {
        // Log all unhandled rejections
        process.on("unhandledRejection", get_error_handler_1.getErrorHandler(this.log));
        // Load the given appFns along with the default ones
        appFns.concat(defaultAppFns).forEach((appFn) => this.load(appFn));
        // Register error handler as the last middleware
        this.server.use(pino_http_1.default({
            logger: this.log,
        }));
    }
    start() {
        this.log.info(`Running Probot v${this.version} (Node.js: ${process.version})`);
        const port = this.options.port || 3000;
        const { host } = this.options;
        const printableHost = host !== null && host !== void 0 ? host : "localhost";
        this.httpServer = this.server
            .listen(port, ...(host ? [host] : []), () => {
            if (this.options.webhookProxy) {
                webhook_proxy_1.createWebhookProxy({
                    logger: this.log,
                    path: this.options.webhookPath,
                    port: this.options.port,
                    url: this.options.webhookProxy,
                });
            }
            this.log.info(`Listening on http://${printableHost}:${port}`);
        })
            .on("error", (error) => {
            if (error.code === "EADDRINUSE") {
                this.log.error(`Port ${this.options.port} is already in use. You can define the PORT environment variable to use a different port.`);
            }
            else {
                this.log.error(error);
            }
            process.exit(1);
        });
        return this.httpServer;
    }
    stop() {
        if (!this.httpServer)
            return;
        this.httpServer.close();
    }
}
exports.Probot = Probot;
exports.createProbot = (options) => {
    options.log = options.log || get_log_1.getLog();
    options.log.warn(new deprecation_1.Deprecation(`[probot] "createProbot(options)" is deprecated, use "new Probot(options)" instead`));
    return new Probot(options);
};
//# sourceMappingURL=index.js.map