"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const express_1 = __importDefault(require("express"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const get_authenticated_octokit_1 = require("./octokit/get-authenticated-octokit");
const probot_octokit_1 = require("./octokit/probot-octokit");
const get_log_1 = require("./helpers/get-log");
const get_octokit_throttle_options_1 = require("./octokit/get-octokit-throttle-options");
const get_probot_octokit_with_defaults_1 = require("./octokit/get-probot-octokit-with-defaults");
const webhook_event_check_1 = require("./helpers/webhook-event-check");
const alias_log_1 = require("./helpers/alias-log");
const get_webhooks_1 = require("./octokit/get-webhooks");
/**
 * The `app` parameter available to `ApplicationFunction`s
 *
 * @property {logger} log - A logger
 */
class Application {
    constructor(options) {
        this.log = alias_log_1.aliasLog(options.log || get_log_1.getLog());
        // TODO: support redis backend for access token cache if `options.redisConfig || process.env.REDIS_URL`
        const cache = options.cache ||
            new lru_cache_1.default({
                // cache max. 15000 tokens, that will use less than 10mb memory
                max: 15000,
                // Cache for 1 minute less than GitHub expiry
                maxAge: Number(process.env.INSTALLATION_TOKEN_TTL) || 1000 * 60 * 59,
            });
        const Octokit = get_probot_octokit_with_defaults_1.getProbotOctokitWithDefaults({
            githubToken: options.githubToken,
            Octokit: options.Octokit || probot_octokit_1.ProbotOctokit,
            appId: options.id,
            privateKey: options.privateKey,
            cache,
        });
        this.state = {
            cache,
            githubToken: options.githubToken,
            log: this.log,
            Octokit,
            octokit: options.octokit || new Octokit(),
            throttleOptions: options.throttleOptions ||
                get_octokit_throttle_options_1.getOctokitThrottleOptions({
                    log: this.log,
                    throttleOptions: options.throttleOptions,
                    redisConfig: options.redisConfig,
                }),
            webhooks: {
                path: options.webhookPath,
                secret: options.secret,
            },
        };
        this.router = express_1.default.Router();
        this.webhooks = options.webhooks || get_webhooks_1.getWebhooks(this.state);
        this.on = (eventNameOrNames, callback) => {
            // when an app subscribes to an event using `app.on(event, callback)`, Probot sends a request to `GET /app` and
            // verifies if the app is subscribed to the event and logs a warning if it is not.
            //
            // This feature will be moved out of Probot core as it has side effects and does not work in a stateless environment.
            webhook_event_check_1.webhookEventCheck(this.state, eventNameOrNames);
            return this.webhooks.on(eventNameOrNames, callback);
        };
        this.receive = this.webhooks.receive;
    }
    /**
     * Loads an ApplicationFunction into the current Application
     * @param appFn - Probot application function to load
     */
    load(appFn) {
        if (Array.isArray(appFn)) {
            appFn.forEach((a) => this.load(a));
        }
        else {
            appFn(this);
        }
        return this;
    }
    /**
     * Get an {@link http://expressjs.com|express} router that can be used to
     * expose HTTP endpoints
     *
     * ```
     * module.exports = app => {
     *   // Get an express router to expose new HTTP endpoints
     *   const route = app.route('/my-app');
     *
     *   // Use any middleware
     *   route.use(require('express').static(__dirname + '/public'));
     *
     *   // Add a new route
     *   route.get('/hello-world', (req, res) => {
     *     res.end('Hello World');
     *   });
     * };
     * ```
     *
     * @param path - the prefix for the routes
     * @returns an [express.Router](http://expressjs.com/en/4x/api.html#router)
     */
    route(path) {
        if (path) {
            const router = express_1.default.Router();
            this.router.use(path, router);
            return router;
        }
        else {
            return this.router;
        }
    }
    /**
     * Authenticate and get a GitHub client that can be used to make API calls.
     *
     * You'll probably want to use `context.github` instead.
     *
     * **Note**: `app.auth` is asynchronous, so it needs to be prefixed with a
     * [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)
     * to wait for the magic to happen.
     *
     * ```js
     *  module.exports = (app) => {
     *    app.on('issues.opened', async context => {
     *      const github = await app.auth();
     *    });
     *  };
     * ```
     *
     * @param id - ID of the installation, which can be extracted from
     * `context.payload.installation.id`. If called without this parameter, the
     * client wil authenticate [as the app](https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/#authenticating-as-a-github-app)
     * instead of as a specific installation, which means it can only be used for
     * [app APIs](https://developer.github.com/v3/apps/).
     *
     * @returns An authenticated GitHub API client
     */
    async auth(installationId, log) {
        return get_authenticated_octokit_1.getAuthenticatedOctokit(Object.assign({}, this.state, log ? { log } : null), installationId);
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map